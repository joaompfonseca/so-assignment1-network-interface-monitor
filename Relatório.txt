NOME:
	netifstat

SINOPSE:	
	./netifstat.sh [-c interfaces] [-p n_interfaces] [-b|-k|-m] [-t|-r|-T|-R] [-v] [-l] [segundos]

DESCRIÇÃO:
	Permite visualizar a quantidade de dados transmitidos e recebidos nas interfaces
	de rede selecionadas e as respetivas taxas de transferência para períodos de 
	tempo pré-estabelecidos.
	Ordenação por defeito: nome da interface, alfabeticamente.

OBRIGATÓRIO:
	segundos [inteiro/float] 	: o período entre recolhas de dados.
	
OPCIONAL:
	-c [regex]					: seleção das interfaces de rede a visualizar.
	
	-p [inteiro]				: número de interfaces a visualizar
	
	-b 							: visualizar os dados em bytes
	-k 							: visualizar os dados em kilobytes
	-m 							: visualizar os dados em megabytes
	
	-t 							: ordenar por TX crescente
	-r 							: ordenar por RX crescente
	-T 							: ordenar por TRATE crescente
	-R 							: ordenar por RRATE crescente
	
	-v 							: inverter ordenação
	
	-l							: funciona em loop. A tabela terá duas colunas extra que mostram
					  		      o total de dados recebidos e transmitidos desde o início da
					  			  execução do script.
						
RELATÓRIO DA ABORDAGEM UTILIZADA, ESCRITA DO CÓDIGO E TESTAGEM DO SCRIPT:

1. Organização e estrutura do script

	Antes mesmo de começar a escrever código, discutiu-se a estratégia a adotar na resolução do problema
proposto. Após analisar o que era pedido no enunciado, decidiu-se adotar a técnica de "dividir e conquistar",
que consiste na divisão do problema principal em outros mais pequenos e fáceis de resolver.

		> Problema principal - o script "netifstat.sh";
		> Problemas secundários - as funções criadas no script, que resolvem tarefas específicas.

	Portanto, este script está divido em duas partes, de forma a facilitar a leitura do mesmo:

		> Zona das Funções - onde estão declaradas as funções.
		> Zona do Main  - onde são chamadas as funções, de acordo com a lógica implementada.

	As funções criadas para a resolução deste problema são as seguintes: 

		> get_args() - Valida, determina e guarda em variáveis as opções e argumentos passados ao script;
		> get_data() - Recolhe e guarda em arrays os dados obtidos através do comando "ifconfig";
		> sort_data() - Ordena os dados nos arrays de acordo com a ordenação escolhida;
		> print_table() - Imprime na consola a tabela formatada com os dados nos arrays.

2. Nomes e tipos de dados das variáveis

	Apesar de não haverem tipos de dados em bash, por uma questão de organização foram atribuidos a cada variável.

	Para os argumentos fornecidos ao script (descritos acima), os nomes das variáveis são iguais ao nome da opção 
(exceto s, o período entre recolha de dados):

		  Opção	: Nome da Var.	: Tipo           : Características
		  ------:---------------:----------------:-------------------------------------------------------
		> s 	: time			: float	 		 : obrigatório; número inteiro ou decimal; maior que zero
		> c 	: if_filter		: string (regex) : comprimento maior que zero
		> p     : if_nMax		: integer		 : número inteiro; maior que zero
		> b 	: b				: boolean		 :  \
		> k 	: kb			: boolean		 :  | são incompatíveis
		> m 	: mb			: boolean		 :  /
		> t 	: sTX			: boolean		 :  \
	    > r 	: sRX			: boolean		 :  | são incompatíveis
		> T 	: sTR			: boolean		 :  |
	    > R		: sRR			: boolean		 :  /
		> v		: sRev			: boolean		 : 
		> l		: loop			: boolean		 : 

	Se várias opções incompatíveis forem fornecidas, é considerada a última que aparecer na invocação do script.

	Para os arrays que armazenam os dados recolhidos do comando "ifconfig", foram definidos os seguintes nomes:
	
		  Nome do Array	: Tipo           : Descrição
		  --------------:----------------:-------------------------------------
		> if_names		: string[]	 	 : Nomes das interfaces
		> if_TX			: int[]	 	 	 : TXs das interfaces, em bytes
		> if_RX			: int[]	 	 	 : RXs das interfaces, em bytes 
		> if_TR 		: float[]	 	 : TRs das interfaces, em bytes/segundo
		> if_RR 		: float[]	 	 : RRs das interfaces, em bytes/segundo 
		> if_TXTOT 		: int[]	 	 	 : TXs totais das interfaces, em bytes 
		> if_RXTOT 		: int[]	 	 	 : RXs totais das interfaces, em bytes

	Para determinar a diferença de valores entre recolhas de dados, é preciso guardar os dados de cada recolha em
dois arrays auxiliares. Os nomes desses arrays têm um sufixo sugestivo, indicando se se trata da recolha anterior
ou da recolha atual:

		  Sufixo	: Descrição		    : Exemplos concretos
		  ----------:-------------------:-----------------------
		> prev		: recolha anterior  : if_TX_prev, if_RX_prev
		> curr		: recolha atual		: if_TX_curr, if_RX_curr

	Os arrays if_TX e if_RX necessitam destes arrays auxiliares, pois guardam a diferença de valores desses dois.
		
 3. Funções e testes

 3.1. print_table()
	
	Esta foi a primeira função a ser desenvolvida. Para a testar, os arrays foram predefinidos com os dados que constavam
do enunciado, e foi definida a variável "loop":

		if_names=("eth0" "wlan" "lo")
		if_TX=(123456 3223 456)
		if_RX=(23456 904 234)
		if_TR=(12345.6 322.3 45.6)
		if_RR=(2345.6 23.4 90.4)
		if_TXTOT=(123456 3223 456)
		if_RXTOT=(23456 904 234)	

		loop=1

	Vale a pena referir que, dentro da função, foi utilizado um pequeno truque para sucintamente imprimir ou não os dados
necessários no caso de o script ser invocado em loop:

		# Cabeçalho
		[[ $loop -eq 1 ]] && printf " $header_loop" "TXTOT" "RXTOT"

		# Linha
		[[ $loop -eq 1 ]] && printf " $line_loop" ${if_TXTOT[i]} ${if_RXTOT[i]}

	Numa expressão booleana [arg1] && [arg2], se arg1 for true (1), então arg2 será avaliada. No entanto, se arg1 for
false (0), então arg2 não será avaliada, pois arg1 já é falsa.
			
3.2. sort_data()

	Para testar esta função, foram definidas as variáveis que alteram a ordenação ("sTX", "sRX", "sTR", "sRR", "sRev"),
considerando desde já que variáveis incompatíveis não podem ser true (1) ao mesmo tempo. Os seus valores foram mudados
consoante o tipo de ordenação, e os resultados foram verificados recorrendo à função print_table() definida anteriormente.

	A ordenação tira partido do facto dos dados de cada interface "i" estarem guardados no índice "i" de cada array. Após
escolher que dados ordenar, foi possível extrair as novas posições dos índices após a ordenação. O array com esses índices
foi determinado recorrendo a apenas uma linha de código:

		indexes=($( printf "%s\n" "${sort_data[@]}" | nl -v0 | sort -$sort_type -k2 | cut -f1 ))

	Com os índices dos dados ordenados da forma pretendida, aplicou-se essa nova ordem a todos os arrays de dados.
Recorreu-se a arrays temporários para salvaguardar os dados desordenados, pois os arrays originais seriam modificados pela
nova ordenação e alguns dos dados poderiam ser sobrescritos.




